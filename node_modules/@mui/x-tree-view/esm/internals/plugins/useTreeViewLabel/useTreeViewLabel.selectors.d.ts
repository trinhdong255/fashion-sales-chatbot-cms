import { UseTreeViewLabelSignature } from "./useTreeViewLabel.types.js";
import { TreeViewRootSelector } from "../../utils/selectors.js";
/**
 * Check if an item is editable.
 * @param {TreeViewState<[UseTreeViewItemsSignature]>} state The state of the tree view.
 * @param {TreeViewItemId} itemId The id of the item to check.
 * @returns {boolean} `true` if the item is editable, `false` otherwise.
 */
export declare const selectorIsItemEditable: ((state: any, itemId: string) => boolean) & {
  clearCache: () => void;
  resultsCount: () => number;
  resetResultsCount: () => void;
} & {
  resultFunc: (resultFuncArgs_0: {
    isItemEditable: ((item: any) => boolean) | boolean;
    editedItemId: string | null;
  } | undefined, resultFuncArgs_1: import("../../..").TreeViewBaseItem<import("../../..").TreeViewDefaultItemModelProperties>) => boolean;
  memoizedResultFunc: ((resultFuncArgs_0: {
    isItemEditable: ((item: any) => boolean) | boolean;
    editedItemId: string | null;
  } | undefined, resultFuncArgs_1: import("../../..").TreeViewBaseItem<import("../../..").TreeViewDefaultItemModelProperties>) => boolean) & {
    clearCache: () => void;
    resultsCount: () => number;
    resetResultsCount: () => void;
  };
  lastResult: () => boolean;
  dependencies: [TreeViewRootSelector<UseTreeViewLabelSignature, true>, (state: any, itemId: string) => import("../../..").TreeViewBaseItem<import("../../..").TreeViewDefaultItemModelProperties>];
  recomputations: () => number;
  resetRecomputations: () => void;
  dependencyRecomputations: () => number;
  resetDependencyRecomputations: () => void;
} & {
  argsMemoize: typeof import("reselect").weakMapMemoize;
  memoize: typeof import("reselect").weakMapMemoize;
};
/**
 * Check if the given item is being edited.
 * @param {TreeViewState<[UseTreeViewLabelSignature]>} state The state of the tree view.
 * @param {TreeViewItemId} itemId The id of the item to check.
 * @returns {boolean} `true` if the item is being edited, `false` otherwise.
 */
export declare const selectorIsItemBeingEdited: ((state: any, itemId: string | null) => boolean) & {
  clearCache: () => void;
  resultsCount: () => number;
  resetResultsCount: () => void;
} & {
  resultFunc: (resultFuncArgs_0: {
    isItemEditable: ((item: any) => boolean) | boolean;
    editedItemId: string | null;
  } | undefined, resultFuncArgs_1: string | null) => boolean;
  memoizedResultFunc: ((resultFuncArgs_0: {
    isItemEditable: ((item: any) => boolean) | boolean;
    editedItemId: string | null;
  } | undefined, resultFuncArgs_1: string | null) => boolean) & {
    clearCache: () => void;
    resultsCount: () => number;
    resetResultsCount: () => void;
  };
  lastResult: () => boolean;
  dependencies: [TreeViewRootSelector<UseTreeViewLabelSignature, true>, (_: any, itemId: string | null) => string | null];
  recomputations: () => number;
  resetRecomputations: () => void;
  dependencyRecomputations: () => number;
  resetDependencyRecomputations: () => void;
} & {
  argsMemoize: typeof import("reselect").weakMapMemoize;
  memoize: typeof import("reselect").weakMapMemoize;
};
/**
 * Check if an item is being edited.
 * @param {TreeViewState<[UseTreeViewLabelSignature]>} state The state of the tree view.
 * @returns {boolean} `true` if an item is being edited, `false` otherwise.
 */
export declare const selectorIsAnyItemBeingEdited: ((state: import("../../corePlugins/useTreeViewId/useTreeViewId.types").UseTreeViewIdState & Partial<import("./useTreeViewLabel.types").UseTreeViewLabelState> & {
  cacheKey: import("../../models").TreeViewStateCacheKey;
}) => boolean) & {
  clearCache: () => void;
  resultsCount: () => number;
  resetResultsCount: () => void;
} & {
  resultFunc: (resultFuncArgs_0: {
    isItemEditable: ((item: any) => boolean) | boolean;
    editedItemId: string | null;
  } | undefined) => boolean;
  memoizedResultFunc: ((resultFuncArgs_0: {
    isItemEditable: ((item: any) => boolean) | boolean;
    editedItemId: string | null;
  } | undefined) => boolean) & {
    clearCache: () => void;
    resultsCount: () => number;
    resetResultsCount: () => void;
  };
  lastResult: () => boolean;
  dependencies: [TreeViewRootSelector<UseTreeViewLabelSignature, true>];
  recomputations: () => number;
  resetRecomputations: () => void;
  dependencyRecomputations: () => number;
  resetDependencyRecomputations: () => void;
} & {
  argsMemoize: typeof import("reselect").weakMapMemoize;
  memoize: typeof import("reselect").weakMapMemoize;
};